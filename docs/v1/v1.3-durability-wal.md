# DriftQ v1.3 — Durability / WAL (Semantics)

This document defines the **v1.3 durability contract** for DriftQ’s Write-Ahead Log (WAL). The WAL exists so a broker restart can restore topics/messages and consumer offsets.

## What we guarantee (and what we don’t)

Guaranteed / intended behavior (when WAL is enabled and functioning):
- Produced messages are appended to the WAL **before** being committed to in-memory state.
- Consumer offset progress is appended to the WAL **only when progress advances**.
- On startup, the broker can **replay** the WAL to rebuild:
  - topics and their partitions (as observed in the WAL)
  - messages (topic/partition/offset/key/value + supported metadata)
  - consumer offsets (topic/group/partition -> last acked offset)

Not guaranteed in v1.3:
- durability if WAL append fails (operations fail instead)
- compaction/cleanup/retention of WAL
- transactional coupling across multiple records (e.g., “message + offset” atomic bundles)
- durable in-flight retry state (attempt counters, last_error, backoff timers) unless added later
- protection against disk corruption beyond basic file append semantics

## Terms

- **WAL**: an append-only log of records used to reconstruct state on restart.
- **Replay**: reading WAL records and rebuilding in-memory state.
- **Record**: a typed WAL entry (message record, offset record, etc.).
- **Last-acked offset**: the stored consumer position per (topic, group, partition).

## Record types (v1.3)

v1.3 stores two core record types:

### 1) Message record
Represents a produced message written to durable storage.

Fields (conceptually):
- `topic`
- `partition`
- `offset`
- `key`
- `value`
- optional metadata (routing label/meta, envelope fields that are supported)

### 2) Offset record
Represents consumer progress.

Fields (conceptually):
- `topic`
- `group`
- `partition`
- `offset` (last acked)

## Produce durability semantics

When `Produce(topic, msg)` succeeds with WAL enabled:
1) The broker appends a **message record** to the WAL.
2) If WAL append succeeds, the broker commits the message to in-memory topic/partition state.
3) If WAL append fails, produce fails and the message is **not** committed to memory.

This makes the WAL the source of truth for restart recovery.

## Ack / offset durability semantics

When `Ack(topic, group, partition, offset)` is called:
- The broker treats stored offsets as “**last acked offset**”.
- If the incoming `offset` is **<=** the stored offset, the Ack is considered duplicate/late:
  - it may still remove the message from in-flight,
  - but it does **not** append to WAL.
- If the incoming `offset` is **>** the stored offset, it advances progress:
  1) append an **offset record** to the WAL
  2) update the stored offset in memory

Rule:
- The broker only appends offset records when the stored offset moves forward.

## Replay semantics (startup recovery)

On startup, with WAL enabled:
- The broker reads all WAL records in order.
- For each **message record**:
  - ensure topic exists
  - ensure partition exists (grow as needed)
  - append the message to the in-memory partition log
  - update topic’s `nextOffset` to at least `offset+1`
- For each **offset record**:
  - ensure consumer offsets maps exist
  - update stored offset to the max of current and the replayed offset

Important detail:
- Topic partition counts during replay are derived from observed message partitions in the WAL.
  - (If a topic was created with N partitions but never had messages in some partitions, replay may not “know” about those empty partitions unless creation is also logged. v1.3 accepts this limitation.)

## Failure and crash expectations

- If the broker crashes after WAL append but before responding, a client may retry produce.
- Without additional producer idempotency, this could cause duplicates.
- v1.6 introduces idempotency semantics; this doc focuses only on WAL durability.

If WAL is not enabled (nil WAL):
- all state is in-memory only and is lost on restart.

## Non-goals for v1.3

- WAL compaction, retention, or segmenting
- checksums / corruption repair
- durable retry state (attempt counts, backoff schedule, last_error) — tracked separately
- durable topic creation records (topic metadata in WAL)

## Example flow

### Restart recovery
1) Broker runs with WAL enabled and accepts produces + acks.
2) Broker process stops.
3) Broker restarts.
4) Broker replays WAL:
   - rebuilds topics/partitions/messages
   - restores consumer offsets
5) Broker resumes dispatch based on restored in-memory state.
