# DriftQ v1.2 — Partitions (minimal) (Semantics)

This document defines the **v1.2 contract** for partitions so partitioning behavior stays stable as DriftQ evolves.

## What we guarantee (and what we don’t)

Guaranteed / intended behavior:
- A topic is created with **N partitions** (`partitions >= 1`).
- Each message is assigned to **exactly one partition** at produce time.
- Within a single partition, messages are delivered in **offset order** (subject to at-least-once redelivery).
- Consumers receive `partition` and `offset` with every delivered message.
- Consumer offsets are tracked **per partition** per (topic, group, partition).

Not guaranteed in v1.2:
- strict ordering across partitions (there is no global order across the whole topic)
- perfect load balancing across partitions (depends on key distribution)
- re-partitioning (changing partition count after topic creation)
- exactly-once delivery

## Key terms

- **Partition**: an ordered stream within a topic. Each message belongs to one partition.
- **Key**: optional bytes used to deterministically choose a partition.
- **Partition override**: optional explicit partition selection via envelope (if provided).
- **Offset**: position assigned to a message for tracking and delivery progress.

## Partition representation (internal)

Internally, v1.2 represents topic state as:
- `topic.partitions`: a slice/array of partitions
- each partition holds a sequence of messages
- each message carries `Partition` and `Offset` fields

(Exact structs may evolve; this describes the behavior.)

## Partition selection (hash-based partitioning)

When producing a message to a topic with N partitions:

1) **Partition override (if provided) wins**
   - If `envelope.partition_override` is set, that partition index is used.
   - If the override is out of range (`<0` or `>= N`), produce fails.

2) Otherwise, **hash-based partitioning**
   - If `key` is non-empty, the broker computes a deterministic hash of the key and selects:
     - `partition = hash(key) % N`
   - If `key` is empty, the broker uses `partition = 0` (MVP default).

Stability contract:
- Given the same `key` and the same partition count `N`, the partition selection is deterministic.

## Produce/consume partition-awareness

### Produce
- Each produced message is stored in exactly one partition.
- The assigned `partition` and `offset` are part of the broker’s message metadata.

### Consume
- Consumers subscribe by `(topic, group)` (no per-partition subscribe API in v1.2).
- The broker dispatches from all partitions for that topic and group (subject to in-flight limits).
- Delivered messages include:
  - `partition`
  - `offset`
  - `attempts` (delivery attempt count)
  - payload (`key`, `value`)

## Ordering and duplicates

Within a partition:
- New messages are appended in offset order.
- Under normal operation, dispatch walks offsets forward per partition.

Because v1.2 supports retries/redelivery:
- A message may be delivered more than once.
- Consumers must treat duplicates as possible (at-least-once).

## Non-goals for v1.2

- partition rebalancing / consumer assignment strategies (Kafka-style rebalancing)
- dynamic partition expansion/shrink
- cross-partition transactions or ordering
- per-partition consumer APIs

## Example flows

### Two keys across multiple partitions
Topic has `N=3` partitions.

- message A key="user:1" → partition = hash("user:1") % 3
- message B key="user:1" → same partition as A
- message C key="user:2" → possibly different partition

This ensures per-key ordering **within the selected partition**.

### Partition override
Producer sets `envelope.partition_override = 2`:
- message always goes to partition 2 (if topic has at least 3 partitions)
- if topic has only 2 partitions (0 and 1), produce fails
