# DriftQ v1.1 — Broker core + consumer groups (Semantics)

This document defines the **v1.1 contract** for the broker core and consumer groups so behavior stays consistent as DriftQ evolves.

## What we guarantee (and what we don’t)

DriftQ v1.1 provides a minimal but real message-queue core:

Guaranteed / intended behavior:
- Topics exist and have **N partitions** (minimal partitioning).
- Messages are persisted in the broker’s in-memory state (and may also be written to a WAL if configured).
- Consumers belong to a **consumer group** identified by a `group` string.
- Messages are dispatched so that **within a group, only one consumer receives a given delivery attempt** (no broadcast).
- Consumer progress is tracked with **per-partition offsets** per (topic, group, partition).
- Consumers must **Ack** messages to advance offsets and stop redelivery.
- If a message is delivered but not Acked within `ackTimeout`, the broker **may redeliver** it (at-least-once delivery).

Not guaranteed in v1.1:
- exactly-once delivery
- strict ordering across partitions (ordering is per partition)
- fairness across partitions under load beyond simple dispatch logic
- durable consumer offsets unless WAL is enabled and successfully appends

## Terms

- **Topic**: named stream of messages with one or more partitions.
- **Partition**: ordered log segment within a topic. Offsets increase per topic (current MVP) but dispatch is per partition.
- **Offset**: monotonically increasing position assigned to each message. Used to track consumer progress.
- **Consumer group**: a logical subscription name. Each group tracks its own offsets.
- **In-flight**: delivered to a consumer channel but not yet Acked.
- **Ack timeout**: if in-flight for too long without Ack, message is eligible for redelivery.

## APIs / surfaces (dev HTTP)

v1.1 uses a dev HTTP surface (to be replaced later by real APIs). Typical endpoints:
- `POST /topics?name=<topic>&partitions=<n>` create topic
- `GET /topics` list topics
- `POST /produce` or query params -> produce message
- `GET /consume?topic=<topic>&group=<group>` stream messages as NDJSON
- `POST /ack?topic=<topic>&group=<group>&partition=<p>&offset=<o>` ack message

## Consumer groups and dispatch semantics

### Group membership
- A consumer group is identified by `(topic, group)`.
- Multiple consumers can concurrently `Consume(topic, group)`.
- The broker maintains a list of consumer channels for each (topic, group).

### No broadcast within a group
For a given (topic, group), each delivery attempt of a message is sent to **exactly one** consumer channel from that group.

### Round-robin selection
Within a group, the broker selects the next consumer channel in a round-robin manner for each dispatch event.

## Offsets and acknowledgements

### Offset tracking model
Offsets are tracked as:

**(topic, group, partition) → last-acked offset**

Notes:
- Stored offset represents **“last acked offset”**.
- If no offset exists yet for a partition, it is treated as `-1` (nothing acked).

### Ack behavior
When the consumer Ack’s `(topic, group, partition, offset)`:
- If `offset` is **greater** than the current stored offset, the broker advances progress and (if WAL is enabled) appends an offset record.
- If `offset` is **<=** current stored offset, Ack is treated as a duplicate/late Ack; it is still considered “done” and the broker removes it from in-flight if present.

After Ack:
- the broker removes that offset from the in-flight set
- the broker dispatches any newly eligible messages

## In-flight limit (backpressure on dispatch)

The broker enforces a limit on the number of **unacked (in-flight) messages** per:

**(topic, group, partition)**

Behavior:
- if the in-flight set for a (topic, group, partition) reaches `maxInFlight`, the broker stops dispatching more messages for that partition to that group until Acks arrive.

## Ack timeout and redelivery (slow consumer handling)

If a message is delivered but not Acked within `ackTimeout`:
- the broker considers it eligible for redelivery
- the broker may redeliver it to a consumer in the same group
- the `attempts` counter on the delivered message increases per delivery attempt

This results in **at-least-once delivery** semantics. Consumers should be prepared to handle duplicates.

## Producer backpressure (buffer limits) and overload response

The broker enforces partition buffer limits to avoid unbounded memory growth. Two knobs exist:

- **max buffered messages per partition**
- **max buffered bytes per partition** (key + value sizes)

Behavior when limits are exceeded:
- produce is rejected with a backpressure/overload error
- HTTP layer returns **429 / RESOURCE_EXHAUSTED**, including a suggested retry delay (`Retry-After` / `retry_after_ms`)

## Durability notes (WAL)

If a WAL is configured:
- messages are appended to WAL before being committed to in-memory state
- consumer offsets are appended to WAL **only when advancing progress**
- on startup, the broker can replay WAL to reconstruct:
  - topics/partitions/messages
  - consumer offsets

If WAL append fails, the operation fails (produce/ack fail accordingly).

## Non-goals for v1.1

- DLQ routing
- exactly-once processing
- durable in-flight / retry schedule state
- observability/metrics beyond basic behavior
- production-grade APIs (v1.7+)

## Example flows

### Basic consume + ack
1) Producer sends message to `topic=test`.
2) Consumer connects: `GET /consume?topic=test&group=g1`.
3) Broker delivers message with `(partition, offset)`.
4) Consumer processes and calls `POST /ack?...&partition=<p>&offset=<o>`.
5) Broker advances offset and stops redelivering that message.

### Slow consumer (timeout redelivery)
1) Broker delivers message attempt=1.
2) Consumer does not Ack within `ackTimeout`.
3) Broker redelivers attempt=2 (possibly to a different consumer in the same group).
4) Consumer eventually Ack’s; broker advances offset and stops retries.
