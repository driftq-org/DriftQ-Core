# DriftQ v1.5 — AI-native router hook (Brain v0) (Semantics)

This document defines the **v1.5 contract** for the “brain hook” (router) in DriftQ-Core. The goal is to make DriftQ **AI-native** by letting the core ask an external “brain” where a message should go and how it should be labeled—without embedding any AI dependencies in the core.

## What we guarantee (and what we don’t)

Guaranteed / intended behavior:
- DriftQ-Core exposes a **Router interface** (the “brain contract”).
- On produce, if a router is configured, the broker calls the router with `(ctx, producerTopic, msg)`.
- If the router returns successfully, DriftQ-Core stores the router’s decision as message metadata:
  - `routing.label`
  - `routing.meta`
- The router may also request routing controls:
  - `target_topic`
  - `partition_override`
- Router routing controls override producer-specified routing controls (router “wins” for MVP).
- If no router is configured, behavior is unchanged (normal produce semantics).

Not guaranteed in v1.5:
- any specific AI model or tooling (Agno/OpenAI/etc. live elsewhere)
- correctness of router decisions (router is advisory; core just applies it)
- policy enforcement, authz, quotas
- retries around router failures (router errors are currently “best-effort”)
- stable taxonomy for labels/meta (that evolves)

## Why this exists

Up to v1.4, DriftQ is “just” a solid queue:
- topics + partitions
- consumer groups + offsets + acks
- WAL + replay
- agent envelope metadata

v1.5 is where DriftQ becomes AI-native:
- The broker can ask a brain: **“what is this message?”** and **“where should it go?”**
- The decision is stored with the message so consumers, observability, and downstream tooling can use it.

## Router interface contract

Router is defined as:

- Input:
  - `topic`: the topic the producer requested (before any overrides)
  - `msg`: the message (payload + envelope if present)
- Output:
  - `RoutingDecision`:
    - `Label` (string)
    - `TargetTopic` (string, optional)
    - `PartitionOverride` (*int, optional)
    - `Meta` (map[string]string)

### Router call semantics
- The router is invoked **during Produce**, before the message is committed to memory/WAL.
- If the router returns `(decision, nil)`:
  - `routing.label` and `routing.meta` are set on the message.
  - If `decision.target_topic` or `decision.partition_override` are set, they are applied (by writing into the message’s envelope).
- If the router returns an error:
  - v1.5 treats this as non-fatal to core behavior:
    - core can proceed without routing metadata, or skip applying overrides
  - (Exact behavior is implementation-defined for MVP; the stable contract is that router failure should not crash the broker.)

## Precedence rules

When multiple actors can influence routing:

1) **Router** (if configured and returns successfully)
2) **Producer envelope routing controls**
3) **Default routing logic** (hash(key) / partition 0 if key empty)

So:
- Router override wins over producer `target_topic` / `partition_override`.
- Producer routing controls win over default hashing.

## Stored metadata (what consumers see)

When routing is present, consumers receive:

- `routing.label`: string
- `routing.meta`: string map

This metadata is informational (for now). It can be used for:
- worker selection / filtering
- metrics and dashboards
- future policy routing or governance
- debugging (why did this message go here?)

## Durability notes (WAL)

When WAL is enabled, routing metadata is persisted with message records (as supported by the WAL entry schema), so it is restored on replay.

## Non-goals for v1.5

- running LLM calls inside the core
- embedding-specific storage, vector routing, policy DSLs
- retries/backoff around router calls
- router-driven fanout/multi-route (single route only in v1.5)
- security/governance enforcement

## Example decision

Router returns:

```json
{
  "label": "finance:classification",
  "target_topic": "tasks.finance.classify",
  "partition_override": null,
  "meta": {
    "source": "agno-router",
    "model": "gpt-4.1",
    "score": "0.92"
  }
}
```

Resulting behavior:
- message is stored with `routing.label` + `routing.meta`
- message is routed to `tasks.finance.classify` instead of producer topic
- consumer receives the routing metadata along with envelope/payload

## Practical worker pattern (preview)

Workers can use `routing.label` to decide how to handle messages, and use v1.6 idempotency to dedupe side effects across retries.
