# DriftQ v1.6 — Idempotency + “Exactly-once-ish effects” (Semantics)

This document defines the **v1.6 contract** so future changes don’t drift the meaning of “exactly-once-ish.”

## What we guarantee (and what we don’t)

DriftQ v1.6 does **not** guarantee exactly-once delivery.

It guarantees **exactly-once-ish side effects at the consumer/worker boundary** *when the worker uses the idempotency helper correctly*.

That means:
- A message may be delivered more than once (at-least-once delivery behavior).
- The worker can ensure it does **not execute the same side effect twice** for the same idempotency identity.

Not guaranteed in v1.6:
- exactly-once delivery
- distributed transactions across external systems (DB/payment APIs/etc.)
- durable in-flight state (unless explicitly persisted in later work)

## Key terms

- **Delivery attempt**: each time the broker sends a message to a consumer channel.
  - Exposed as `attempts` on the delivered message.
  - Attempts increment **on delivery**, not on produce.
- **Ack**: consumer confirms success; broker advances the consumer offset.
- **Nack**: consumer reports failure and provides a failure reason; broker keeps the message eligible for retry.
- **last_error (message)**: latest known failure reason for a message offset while it is in-flight (v1.6: in-memory).
- **Idempotency status**: the broker’s registry state for an idempotency key.

## Idempotency identity / scope

An idempotent operation is identified by the tuple:

**(tenant_id, topic, idempotency_key)**

Notes:
- `tenant_id` may be empty; it is still part of the tuple (empty string is a valid value).
- `topic` is included in the tuple in v1.6. The same `idempotency_key` used in two different topics is treated as **different** operations.
- If `idempotency_key` is empty, **no idempotency behavior** is applied.

## Idempotency store status model (v1.6)

The in-memory idempotency registry stores:

- `PENDING`: operation started (in-flight)
- `COMMITTED`: operation completed successfully
- `FAILED`: operation failed

v1.6 behavior:
- `Begin()` creates/sets `PENDING`.
- `Commit()` sets `COMMITTED`.
- `Fail()` sets `FAILED`.
- If a key is `FAILED`, v1.6 allows retry by replacing `FAILED → PENDING` on a new `Begin()`.

## Producer-side idempotency (broker gate)

When a message includes `envelope.idempotency_key`, the broker performs a lightweight dedupe gate in `Produce()`.

Behavior:
- If the idempotency identity is already `COMMITTED`, `Produce()` is treated as success and the broker **does not enqueue a duplicate message**.
- If the identity is currently `PENDING`, the broker rejects the duplicate produce attempt (to avoid duplicates while the operation is in-flight).
- If the produce path fails after `Begin()`, the broker records `FAILED`.

This prevents duplicated *enqueued messages* for the same key. It does **not** guarantee exactly-once effects unless the consumer follows the consumer-side contract below.

## Consumer-side idempotency (exactly-once-ish effects)

To get “exactly-once-ish effects,” the worker MUST:

1) **Begin / Check “already done?”**
   - Use the broker’s idempotency helper on the consumer side.
   - If the helper reports “already committed,” the worker must **skip side effects** and treat the message as success (Ack it).

2) **Execute side effects**
   - Do the DB write / external call / etc.

3) **Record outcome**
   - On success: `MarkSuccess(...)` and then `Ack`.
   - On failure: `MarkFailure(...)` and optionally `Nack(reason=...)` (or simply do not Ack and let timeout retry happen).

Contract:
- If the same `(tenant_id, topic, idempotency_key)` is delivered again and the registry is `COMMITTED`, the worker can avoid double side effects.

## Retries and redelivery

- Messages become eligible for retry if they are delivered and not acked within `ackTimeout`.
- If `envelope.retry_policy` exists:
  - `max_attempts` limits delivery attempts (attempts count = number of deliveries).
  - `backoff_ms` and `max_backoff_ms` control retry scheduling/backoff.
- If `retry_policy` is absent, messages may still be redelivered due to timeout (MVP behavior).

### Max attempts behavior (current v1.6 behavior)
If `max_attempts` is set and the message reaches that attempt count:
- the broker stops redelivering it
- the broker advances the consumer offset so it won’t resurrect on restart

DLQ routing is planned and tracked separately (see below).

## Failure reasons (`last_error`)

### Message `last_error`
DriftQ tracks the latest failure reason per in-flight message offset.

- If the consumer calls `Nack(..., reason)`, the broker records that string as `last_error` for that message offset.
- If a message times out (no ack) and no explicit reason was recorded, the broker may set:
  - `last_error = "ack_timeout"`
- `last_error` is surfaced to consumers in the delivered message payload.

**v1.6 scope:** message `last_error` is **in-memory** and is lost on broker restart (durability may be added in a later PR).

### Idempotency store `LastError`
The idempotency registry also stores a `LastError` string for `FAILED` operations.
This is a different concept from message `last_error`:
- idempotency `LastError` describes the operation keyed by `(tenant_id, topic, idempotency_key)`
- message `last_error` describes the most recent delivery failure reason for a specific message offset while retrying

## DLQ interaction (planned)

If a message exceeds retry policy (or is later marked non-retryable), DriftQ will route it to a DLQ topic (e.g., `dlq.<topic>`).

DLQ messages should include metadata:
- original `topic / partition / offset`
- `attempts`
- message `last_error`
- envelope fields like `tenant_id` and `idempotency_key`

## Example flows

### Success on first attempt
- attempt=1 delivered
- worker does side effect
- worker `MarkSuccess` + `Ack`
- offset advances; no redelivery

### Failure then success
- attempt=1 delivered
- worker fails and `Nack(reason="db_deadlock")` (or just no Ack)
- broker redelivers (attempt=2+) with `last_error` set
- worker succeeds, `MarkSuccess` + `Ack`
- retries stop

### Duplicate delivery (consumer dedupe)
- attempt=1 delivered; worker succeeds; marks committed; acks
- message is delivered again (redelivery / duplicate / crash timing)
- worker begins and sees already committed → skips side effects → acks
